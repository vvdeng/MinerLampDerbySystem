C51 COMPILER V9.01   MAIN                                                                  02/17/2014 16:03:40 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: d:\Keil4\C51\BIN\C51.EXE main.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #include <reg52.h>
   2          #include<intrins.h>
   3          #include "insideStorage.h"
   4          #include "useful.h"
   5          #include "lcdhz12864.h"
   6          #include "config.h"
   7          #define DATA_PRE 0x50 //¶þ½øÖÆ0101×÷ÎªÊý¾ÝÇ°µ¼
   8          #define DATA_PRE_UPDATE_RACK_STAFF 0x60 //0110 ¸üÐÂÔ±¹¤ÐÅÏ¢Ç°µ¼
   9          #define  _Nop()  _nop_()
  10          
  11          sfr WDT_CONTR = 0xc1; //¿´ÃÅ¹·µØÖ·
  12                        
  13          sfr   S2CON   = 0x9a;                
  14          sfr   S2BUF   = 0x9b;                 
  15          sfr   BRT     = 0x9c;
  16          sfr IPH    = 0xB7;                  
  17          sfr   IE2     = 0xaf;  //ÖÐ¶ÏÔÊÐí¼Ä´æÆ÷2 ×îµÍÎ»ÎªES2            
  18          #define   S2RI    0x01                 
  19          #define   S2TI    0x02                
  20                         
  21          
  22          sbit dispEnableIO=P3^5;
  23          
  24          
  25          //sbit SEL_INH=P4^4;
  26          //sbit LED4=P4^5;
  27          //Ö¸Ê¾µÆ
  28          sbit LED_TXD1 =P1^0;
  29          
  30          sbit LED_RXD1 =P1^1;
  31          sbit LED_TXD2 =P3^3;
  32          
  33          sbit LED_RXD2 =P3^4;
  34          //sbit ledTest =P1^1;
  35          sbit k0=P3^5;
  36          //´®¿Ú1 485¶ÁÐ´¿ØÖÆ
  37          sbit RW_485_1=P3^6;
  38          sbit RW_485_2=P3^7;
  39          
  40          /*sbit k1=P1^4;
  41          sbit k3=P1^5;
  42          sbit k5=P1^6;
  43          sbit k7=P1^7;
  44          */
  45          sbit SEL_A=P1^4;
  46          sbit SEL_B=P1^5;
  47          sbit SEL_C=P1^6;
  48          sbit SEL_D=P1^7;
  49          sbit LED_TEST=P2^7;
  50          sbit LED_TEST2=P2^7;
  51          
  52          #define UNIT_STATE_EMPTY  1
  53          #define UNIT_STATE_CHARGING 2
  54          #define UNIT_STATE_FULL  3
  55          #define UNIT_STATE_ERROR  4
C51 COMPILER V9.01   MAIN                                                                  02/17/2014 16:03:40 PAGE 2   

  56          #define UNIT_STATE_OFFLINE 5
  57          
  58          #define RECEIVE 0x01
  59          #define SEND 0x02
  60          #define SENTENCE_MAX_NUM 6
  61          #define SENTENCE_LEN  32
  62          //×Ô¶¨ÒåÃüÁî¸ñÊ½£ºxxxd dddd  ó{3Î»±íÊ¾ÃüÁî£¬ºó5Î»±íÊ¾µÆ¼ÜµØÖ·
  63          #define CMD_OPEN_DOOR 0xE0
  64          #define CMD_UPDATE_STAFF_INFO 0xC0
  65          #define CMD_REQ_UNIT_INFO 0x80
  66          #define CMD_BRORDCAST 0xf0
  67          #define CMD_SEND_STA 0x80
  68          #define SYM_DATA_END 0xff
  69          
  70          #define COMM_STATE_NOTHING 0
  71          #define COMM_STATE_REQ_UNIT_INFO 1
  72          #define COMM_STATE_REQ_UNIT_INFO_RECEIVE 2
  73          #define COMM_STATE_UPDATE_STAFF 3
  74          #define COMM_STATE_BROADCAST_MESSAGES 4
  75          #define COMM_STATE_BROADCAST_MESSAGES_PREPARE_STEP_1 5
  76          #define COMM_STATE_BROADCAST_MESSAGES_PREPARE_STEP_2 6
  77          #define COMM_STATE_BROADCAST_MESSAGES_PREPARE_STEP_3 7
  78          #define COMM_STATE_REQ_RACK_UNITS_INFO 8
  79          #define COMM_STATE_UPDATE_RACK_STAFF 9
  80          #define COMM_STATE_SEND_STA 10
  81          #define COMM_STATE_OPEN_DOOR 11
  82          #define COMM_STATE_BROADCAST_PREPARE_1 0x01
  83          #define COMM_STATE_BROADCAST_PREPARE_2 0x03
  84          #define COMM_STATE_BROADCAST_PREPARE_3 0x05
  85          
  86          #define DISPLAY_MESSAGE 0
  87          //#define DISPLAY_STATISTICS 1
  88          
  89          uchar  curSentenceIndex,changeMessageTimer=0,currentUnitIndex=1,currentUnitTotalIndex,commState1,commState
             -2,reqUnitInfoInteval,oldCommState=COMM_STATE_NOTHING,staffBufIndex=0,oldTH0=0,oldTL0=0,oldGroup=255,retryCount=0,reqStat
             -eTimeout=0,lockAddr=0;
  90          uint messagesBufIndex=0,reqStateTimer=0;
  91          bit changeMessageFlag=0,readStateFlag=0,receiveMessagesFlag=0,updateRackStaffFlag=0,inAddrSetting=0,isInfr
             -aredAllowed=0,totalRefreshed=0,lockFlag=0;
  92          uchar xdata unitStateArr[101],tempUnitStateArr[101];
  93          
  94          
  95          #define LOCAL_ADDRESS_ADDR  0x0
  96          #define UNITS_NUM_ADDR  0x2
  97          #define MESSAGE_NUM_ADDR  0x4
  98          #define MESSAGE_INTEVAL_ADDR  0x6
  99          #define TIMEOUT_THRESHOLD_ADDR  0x8
 100          #define MESSAGE_LIST_ADDR  0x100
 101          
 102          #define UNIT_STATE_NULL  0
 103          #define UNIT_STATE_EMPTY  1
 104          #define UNIT_STATE_CHARGING 2
 105          #define UNIT_STATE_FULL  3
 106          #define UNIT_STATE_ERROR  4
 107          
 108          uchar xdata stateStat[6]={0};//Ë÷Òý0Î´ÓÃ£¨Ñ²¼ì×ÜÊý£© £¬1 ±íÊ¾¿óµÆÈ¡×ß 2±íÊ¾¿óµÆ³äµç 3±íÊ¾¿óµÆ³äÂú 5±íÊ¾¶ÏÏ
             -ß
 109          
 110          uchar xdata messageBuf[SENTENCE_MAX_NUM][SENTENCE_LEN+1]={'\0'};
 111          uchar tempMessageNum=0;
 112          uchar* xdata menu[]={"µØÖ·ÉèÖÃ","µÆ¼ÜÉèÖÃ","ºìÍâÉèÖÃ","²É¼¯¼ä¸ô"};
 113          
C51 COMPILER V9.01   MAIN                                                                  02/17/2014 16:03:40 PAGE 3   

 114          bit tready,tready2,rready,rready2;
 115          bit isSelected;
 116          
 117          #define FIELD_COUNT 3
 118          #define STAFF_INFO_FIELD_LENGTN 8
 119          #define MESSAGE_BUF_LEN 400
 120          uchar xdata staff_buf[FIELD_COUNT][STAFF_INFO_FIELD_LENGTN];
 121          uchar xdata messagesBuf[MESSAGE_BUF_LEN]={'\0'};
 122          uchar xdata staffBuf[60];
 123          
 124          uchar queryStateInteval=5,queryUnitsNum=20,groupNum=0,groupIndex;
 125          void displayCurrentLedMessage(bit isFirst);
 126          
 127          
 128          /*
 129          //´®¿Ú2Êä³öÊý¾Ý£º
 130          void OutByteS2(uchar k)
 131          {
 132                  S2BUF=k;
 133                  while(!(S2CON&S2TI));
 134                  S2CON&=~S2TI;
 135          }
 136          //´®¿Ú2¶ÁÈ¡Êý¾Ý
 137          uchar GetByteS2(void)
 138          {
 139                  while(!(S2CON&S2RI));
 140                  S2CON&=~S2RI;
 141                  return S2BUF;                   
 142          }
 143          uchar GetByteS2Instance(void)
 144          {       
 145                  delayMs(50);
 146                  if(S2CON&S2RI){
 147                          S2CON&=~S2RI;
 148                          return S2BUF;
 149                  }
 150                  else{
 151                          return 4;//±íÊ¾ÎÞÏìÓ¦
 152                  }       
 153          }*/
 154          void switchIfNecessary(uchar lampNo){
 155   1              uchar group=(lampNo-1)/20;//Ã¿¶þÊ®¸öÒ»×é cd4067
 156   1      //      if(group==oldGroup){
 157   1      //              return;
 158   1      //      }
 159   1              oldGroup=group;
 160   1      
 161   1              SEL_A=(group&0x01);
 162   1              SEL_B=((group>>1)&0x01);
 163   1              SEL_C=((group>>2)&0x01);
 164   1              SEL_D=((group>>3)&0x01);
 165   1      
 166   1              
 167   1      }
 168          void sendCmdAndAddrInstance(uchar cmd,uchar addr){
 169   1      //      switchIfNecessary(addr);
 170   1              RW_485_2=1;
 171   1      
 172   1              
 173   1              S2BUF=cmd;
 174   1              while(!(S2CON&S2TI));
 175   1              S2CON&=~S2TI;
C51 COMPILER V9.01   MAIN                                                                  02/17/2014 16:03:40 PAGE 4   

 176   1      
 177   1              S2BUF=addr;
 178   1      
 179   1              while(!(S2CON&S2TI));
 180   1              S2CON&=~S2TI;
 181   1              
 182   1              RW_485_2=0;
 183   1      }
 184          
 185          void sendDataInstance(uchar ldata,uchar pre){
 186   1              LED_TXD2=~LED_TXD2;
 187   1              RW_485_2=1;
 188   1                      
 189   1              S2BUF=((ldata>>4)&0x0f)|pre;
 190   1              while(!(S2CON&S2TI));
 191   1              S2CON&=~S2TI;
 192   1      
 193   1              S2BUF=(ldata&0x0f)|pre;
 194   1              while(!(S2CON&S2TI));
 195   1              S2CON&=~S2TI;
 196   1              
 197   1              RW_485_2=0;
 198   1              
 199   1              
 200   1      }
 201          void sendDataWithoutSplitInstance(uchar ldata){
 202   1                      LED_TXD2=~LED_TXD2;
 203   1              RW_485_2=1;
 204   1                      
 205   1              S2BUF=ldata;
 206   1              while(!(S2CON&S2TI));
 207   1              S2CON&=~S2TI;
 208   1      
 209   1              
 210   1              RW_485_2=0;
 211   1      }
 212          void sendCmdInstance(uchar ldata){
 213   1              sendDataWithoutSplitInstance(ldata);    
 214   1      }
 215          /*
 216          void sendData(uchar ldata){
 217                  RW_485_2=1;
 218                  S2BUF=ldata;
 219          }*/
 220          /*
 221          void sendCmdAndAddr(uchar cmd,uchar addr){
 222                  uchar temp;
 223          
 224          
 225                  RW_485_2=1;
 226          //      temp=cmd;
 227                  S2BUF=temp;
 228          //      S2CON&=~S2TI;
 229                  while(!(S2CON&S2TI));
 230          
 231                  RW_485_2=1;
 232                  temp=addr;
 233                  if(temp==addr&&(addr==3)){
 234                                  LED_RXD1=~LED_RXD1;
 235                          }
 236                          if(temp==3){
 237                                  LED_TXD1=~LED_TXD1;
C51 COMPILER V9.01   MAIN                                                                  02/17/2014 16:03:40 PAGE 5   

 238                          }
 239                  S2BUF=addr;
 240          
 241          //      S2CON&=~S2TI;
 242                  while(!(S2CON&S2TI));
 243                  RW_485_2=0;
 244          }
 245          void sendData(uchar ldata){
 246                  
 247                  RW_485_2=1;
 248                          
 249                  S2BUF=(ldata>>4)&0x0f;
 250                  S2CON&=~S2TI;
 251                  while(!(S2CON&S2TI));
 252                  S2BUF=ldata&0x0f;
 253                  S2CON&=~S2TI;
 254                  while(!(S2CON&S2TI));
 255                  RW_485_2=0;
 256                  
 257                  
 258          }*/
 259          void reqCurrentUnitInfo(){
 260   1              
 261   1              if(commState2==COMM_STATE_UPDATE_STAFF){
 262   2                      return;
 263   2              }
 264   1              if(currentUnitIndex<=queryUnitsNum){
 265   2                      LED_TXD2=0;
 266   2                      currentUnitTotalIndex=groupIndex*queryUnitsNum+currentUnitIndex;
 267   2                      TR0=0;
 268   2      
 269   2                      IE2 = 0x00;
 270   2                      switchIfNecessary(currentUnitTotalIndex);
 271   2                      sendCmdAndAddrInstance(CMD_REQ_UNIT_INFO,currentUnitTotalIndex);
 272   2              
 273   2      
 274   2      
 275   2      
 276   2      
 277   2                      IE2 = 0x01;
 278   2                      if(isInfraredAllowed==0){
 279   3                              TL0 = 0xD7;             //ÉèÖÃ¶¨Ê±³õÖµ   16Î» 600us Îó²î1%
 280   3                              TH0 = 0xFD;             //ÉèÖÃ¶¨Ê±³õµ
 281   3                              
 282   3                      }
 283   2                      reqUnitInfoInteval=0;
 284   2      
 285   2                      TR0=1;
 286   2              
 287   2      
 288   2              }
 289   1              else{
 290   2              //      readStateFlag=0;
 291   2                      groupIndex++;
 292   2                      if(groupIndex==groupNum){
 293   3                              groupIndex=0;
 294   3                      //      totalRefreshed=1;
 295   3      
 296   3                      }
 297   2                      //Ã¿½áÊø20¸ö¾Í¸üÐÂÏÂ³äµç×´Ì¬
 298   2                      totalRefreshed=1;
 299   2                      commState2=COMM_STATE_NOTHING;
C51 COMPILER V9.01   MAIN                                                                  02/17/2014 16:03:40 PAGE 6   

 300   2                      currentUnitIndex=1;
 301   2                      LED_TXD2=1;
 302   2                      LED_RXD2=1;
 303   2                      TR0=1;
 304   2              
 305   2              }
 306   1      }
 307          void reqNextUnitInfo(){
 308   1              currentUnitIndex++;
 309   1              reqCurrentUnitInfo();
 310   1      }
 311          
 312          void S2INT() interrupt 8
 313          {
 314   1              uchar temp;             
 315   1              if(S2CON&S2RI)
 316   1              {       
 317   2      
 318   2                      S2CON&=~S2RI;
 319   2                      temp=S2BUF;
 320   2              
 321   2                      if(commState2==COMM_STATE_REQ_UNIT_INFO)
 322   2                      {
 323   3                      //      LED_RXD2=~LED_RXD2; 
 324   3                              LED_RXD2=0; //½ÓÊÕµ½Êý¾Ý¸ÄÎª³£Á¿£¬²»ÉÁË¸
 325   3                              if((temp&0xf0)!=DATA_PRE){
 326   4                                      if(retryCount<10)//×î¶à³¢ÊÔ10´Î
 327   4                                      {
 328   5                                              retryCount++;
 329   5                                              reqCurrentUnitInfo();
 330   5                                              
 331   5                                      }
 332   4                                      else{
 333   5                                              //µ±Ç°³äµç¼Ü×´Ì¬±£³Ö²»±ä£¬ÇëÇóÏÂÒ»¸ö×´Ì¬
 334   5                                              retryCount=0;
 335   5                                              reqNextUnitInfo();
 336   5                                      }
 337   4                              }
 338   3                              else{
 339   4                              reqStateTimeout=0;
 340   4                              tempUnitStateArr[currentUnitTotalIndex]=(temp&0x0f);
 341   4                                                      
 342   4                              reqNextUnitInfo();
 343   4                         }
 344   3                      }
 345   2                      
 346   2              }
 347   1              if(S2CON&S2TI)
 348   1              {
 349   2                      
 350   2      /*              if(commState2==COMM_STATE_REQ_UNIT_INFO)
 351   2                      {
 352   2                              
 353   2                              
 354   2                      }
 355   2                      else if(commState2==COMM_STATE_UPDATE_STAFF)
 356   2                      {
 357   2                      
 358   2                      }
 359   2      */      
 360   2                      S2CON&=~S2TI;
 361   2                      RW_485_2=0;
C51 COMPILER V9.01   MAIN                                                                  02/17/2014 16:03:40 PAGE 7   

 362   2      
 363   2              }
 364   1      
 365   1      }
 366          
 367          
 368          
 369          void makeInfo() {
 370   1              uchar m;
 371   1              unitStateArr[0]=configValueArr[CONFIG_ADDR];
 372   1              for (m = 1; m <= configValueArr[CONFIG_UNIT_NUM]; m++) {
 373   2              //      unitStateArr[m] = (unitStateArr[m]+1)%4;
 374   2                      unitStateArr[m] = 0;
 375   2              }
 376   1      }
 377          
 378          //×Ô¶¨ÒåÃüÁî¸ñÊ½£ºxxxd dddd  ó{3Î»±íÊ¾ÃüÁî£¬ºó5Î»±íÊ¾µÆ¼ÜµØÖ· ×î¶à32Î» 0e0
 379          // ½ÓÊÕÃüÁî£º¹ã²¥1000 0000 £»»ñÈ¡³äµç×´Ì¬1010 00000£»¸üÐÂÔ±¹¤ÐÅÏ¢1100 0000£»Í¨ÐÅÕý³£½áÊø 1110 0000
 380          //·¢ËÍÃüÁî£º »ñÈ¡³äµç×´Ì¬1000 0000 ¸üÐÂÔ±¹¤ÐÅÏ¢1100 0000
 381          bit isBroadCast4Addr() {
 382   1              return (SBUF&0xe0)==0x80;
 383   1      }
 384          bit isReqUnitInfo() {
 385   1              return (SBUF&0xe0)==0xA0;
 386   1      }
 387          
 388          bit isUpdateStaffInfo() {
 389   1              return (SBUF&0xe0)==CMD_UPDATE_STAFF_INFO;
 390   1      }
 391          
 392          bit isOpenDoorCmd(){
 393   1              return (SBUF&0xe0)==CMD_OPEN_DOOR;
 394   1      }
 395          
 396          void sendUnitInfo(){
 397   1              uchar m;
 398   1              if(tready==0){ //·¢ËÍÃ¦Âµ
 399   2                      RW_485_1=1;
 400   2                      SBUF=0x80;
 401   2                      while(TI!=1);
 402   2                      TI=0; 
 403   2                      RW_485_1=0;
 404   2              }
 405   1              else{
 406   2                      tready=0 ;
 407   2              //      makeInfo();
 408   2              //      reqUnitInfo();
 409   2                      {
 410   3                              //·¢ËÍµØÖ·,²»¼ÓÊý¾ÝÇ°×º
 411   3                              RW_485_1=1;
 412   3                              SBUF=(unitStateArr[0]); 
 413   3                      while(TI!=1);
 414   3                          TI=0; 
 415   3                              RW_485_1=0;
 416   3                      }
 417   2                      for(m=1;m<=configValueArr[CONFIG_UNIT_NUM];m++) 
 418   2                      {
 419   3                              LED_TXD1=~LED_TXD1;
 420   3                              RW_485_1=1;
 421   3                              SBUF=(unitStateArr[m]|DATA_PRE);        
 422   3                      while(TI!=1);
 423   3                          TI=0; 
C51 COMPILER V9.01   MAIN                                                                  02/17/2014 16:03:40 PAGE 8   

 424   3                              RW_485_1=0;
 425   3                      }
 426   2                      tready=1;
 427   2                      LED_TXD1=1; //Ö¸Ê¾µÆÃð
 428   2              }
 429   1      }
 430          void prepareUpdateStaffInfo(void){
 431   1              RW_485_2=1 ;
 432   1              oldCommState=commState2;
 433   1              commState2=COMM_STATE_UPDATE_STAFF;     
 434   1      }
 435          void endUpdateStaffInfo(void){
 436   1              commState2=oldCommState;
 437   1              if(commState2==COMM_STATE_REQ_UNIT_INFO){
 438   2                      reqCurrentUnitInfo();
 439   2              }
 440   1      }
 441          
 442          void makeUpdateStaff(){
 443   1              
 444   1              uchar m,n,lampNo,tempStaffBufIndex=0;
 445   1      
 446   1              
 447   1      
 448   1                                      lampNo = (staffBuf[tempStaffBufIndex++] & 0x0f) << 4;
 449   1                                      lampNo += (staffBuf[tempStaffBufIndex++] & 0x0f);
 450   1              
 451   1                      for (m = 0; m < FIELD_COUNT; m++) {
 452   2      
 453   2                              for (n = 0; n < STAFF_INFO_FIELD_LENGTN; n++) {
 454   3      
 455   3                                      staff_buf[m][n] = (staffBuf[tempStaffBufIndex++] & 0x0f) << 4;
 456   3                                      staff_buf[m][n] += (staffBuf[tempStaffBufIndex++] & 0x0f);
 457   3                              }
 458   2      
 459   2                      }       
 460   1                      
 461   1                      prepareUpdateStaffInfo();
 462   1              //      LED_TXD1=0;
 463   1                      switchIfNecessary(lampNo);
 464   1                      sendCmdAndAddrInstance(CMD_UPDATE_STAFF_INFO,lampNo);
 465   1      
 466   1      
 467   1                      
 468   1                      for (m = 0; m < FIELD_COUNT; m++) {
 469   2      
 470   2                              for (n = 0; n < STAFF_INFO_FIELD_LENGTN; n++) {
 471   3                                      sendDataInstance(staff_buf[m][n],DATA_PRE_UPDATE_RACK_STAFF);
 472   3                                      
 473   3                              }
 474   2      
 475   2                      }
 476   1                              
 477   1                      
 478   1                      endUpdateStaffInfo();
 479   1              //      LED_TEST=~LED_TEST;
 480   1      
 481   1      
 482   1      }
 483          
 484          void storageBaseInfo(){
 485   1              uchar m,n;
C51 COMPILER V9.01   MAIN                                                                  02/17/2014 16:03:40 PAGE 9   

 486   1              IapEraseSector(IAP_BASEINFO_ADDRESS); 
 487   1              
 488   1          for (m = 0; m < configValueArr[CONFIG_MSG_NUM]; m++) {
 489   2                      for (n = 0; n < SENTENCE_LEN; n++) {
 490   3                              IapProgramByte(IAP_BASEINFO_ADDRESS+MESSAGE_LIST_ADDR+m*SENTENCE_LEN+n, messageBuf[m][n]);
 491   3                      }
 492   2              }
 493   1      }
 494          void storageInfo(){
 495   1      
 496   1              saveConfig();
 497   1              storageBaseInfo();
 498   1      
 499   1      }
 500          void prepareSendMessage(void){
 501   1      //      RW_485_2=1 ;
 502   1              oldCommState=commState2;
 503   1              commState2=COMM_STATE_BROADCAST_MESSAGES;       
 504   1      }
 505          void endSendMessage(void){
 506   1              commState2=oldCommState;
 507   1              if(commState2==COMM_STATE_REQ_UNIT_INFO){
 508   2                      reqCurrentUnitInfo();
 509   2              }
 510   1      }
 511          void sendLedMessages(){
 512   1              uint m=0,n=0;
 513   1              TR0=0;
 514   1              IE2 = 0x00;
 515   1              ES=0;                           
 516   1              switchIfNecessary(101);//ÎÄ×Ö¹ã²¥ÔÚµÚ10×é //20¸öÒ»×éºóÎªµÚ5×é Ë÷Òý´Ó0¿ªÊ¼
 517   1      
 518   1              sendCmdInstance(0xf0);
 519   1              sendDataWithoutSplitInstance(COMM_STATE_BROADCAST_PREPARE_1);
 520   1              sendDataWithoutSplitInstance(COMM_STATE_BROADCAST_PREPARE_2);
 521   1              sendDataWithoutSplitInstance(COMM_STATE_BROADCAST_PREPARE_3);
 522   1              for (m = 0; m < MESSAGE_BUF_LEN; m++) {
 523   2                      sendDataWithoutSplitInstance(messagesBuf[m]);
 524   2              }
 525   1      
 526   1              LED_TXD2=1;//Ö¸Ê¾µÆÃð
 527   1              TR0=1;
 528   1              IE2 = 0x01;
 529   1              ES=1; 
 530   1      
 531   1      }
 532          void makeMessages(){
 533   1              uchar m,n,tempMessageInteval,tempBufIndex=2;//0,1´æ´¢ÏûÏ¢Êý£¬ÒÑ»ñÈ¡
 534   1              
 535   1              
 536   1                      configValueArr[CONFIG_MSG_NUM]=tempMessageNum;
 537   1      
 538   1                      tempMessageInteval = (messagesBuf[tempBufIndex++] & 0x0f) << 4;
 539   1              
 540   1                      tempMessageInteval+= (messagesBuf[tempBufIndex++]  & 0x0f);
 541   1              
 542   1                      for (m = 0; m < configValueArr[CONFIG_MSG_NUM]; m++) {
 543   2      
 544   2                              for (n = 0; n < SENTENCE_LEN; n++) {
 545   3                                      
 546   3                                      messageBuf[m][n] = (messagesBuf[tempBufIndex++] & 0x0f) << 4;
 547   3              
C51 COMPILER V9.01   MAIN                                                                  02/17/2014 16:03:40 PAGE 10  

 548   3                                      messageBuf[m][n] += (messagesBuf[tempBufIndex++] & 0x0f);
 549   3                              }
 550   2      
 551   2                      }       
 552   1              configValueArr[CONFIG_MSG_INTEVAL]=tempMessageInteval;
 553   1          if(configValueArr[CONFIG_DEBUG]==DISPLAY_MESSAGE)
 554   1              {
 555   2                      displayCurrentLedMessage(1);
 556   2              }
 557   1              storageInfo();
 558   1              prepareSendMessage();
 559   1              sendLedMessages();
 560   1              endSendMessage();
 561   1      }
 562          
 563          
 564          void ssio(void)
 565          interrupt 4
 566          {
 567   1                
 568   1              if(RI){
 569   2               RI=0;
 570   2      
 571   2                      if(isBroadCast4Addr()){
 572   3                              commState1=COMM_STATE_BROADCAST_MESSAGES_PREPARE_STEP_1;
 573   3                              return;
 574   3                      }
 575   2      
 576   2                      if(isReqUnitInfo()&&((SBUF&0x1F)==configValueArr[CONFIG_ADDR]))
 577   2                      {
 578   3                              commState1=COMM_STATE_REQ_RACK_UNITS_INFO;
 579   3      
 580   3                              TR0=0;
 581   3                              ES=0; 
 582   3              //              P1=255-4;
 583   3              //              SBUF=1;
 584   3              //              while(TI!=1);
 585   3              //              TI=0; 
 586   3              //              
 587   3                              sendUnitInfo();
 588   3                              commState1=COMM_STATE_NOTHING;
 589   3                              
 590   3                              TR0=1;
 591   3                              ES=1; 
 592   3                              return;
 593   3                      }
 594   2                      if(isUpdateStaffInfo()&&((SBUF&0x1F)==configValueArr[CONFIG_ADDR])){
 595   3                              commState1=COMM_STATE_UPDATE_RACK_STAFF;
 596   3                              LED_TEST2=~LED_TEST2;
 597   3                              staffBufIndex=0;
 598   3                              return;
 599   3                      }
 600   2                      if(isOpenDoorCmd()&&((SBUF&0x1F)==configValueArr[CONFIG_ADDR])){
 601   3                      //      ledTest=0;
 602   3                              commState1=COMM_STATE_OPEN_DOOR;
 603   3                              LED_TEST2=~LED_TEST2;
 604   3                              
 605   3                              return;
 606   3                      }
 607   2                      if((commState1==COMM_STATE_BROADCAST_MESSAGES_PREPARE_STEP_1)){
 608   3                              if(SBUF==COMM_STATE_BROADCAST_PREPARE_1){
 609   4                                      commState1=COMM_STATE_BROADCAST_MESSAGES_PREPARE_STEP_2;
C51 COMPILER V9.01   MAIN                                                                  02/17/2014 16:03:40 PAGE 11  

 610   4                              }
 611   3                              else{
 612   4                                      commState1=COMM_STATE_NOTHING;
 613   4                              }
 614   3                              return;
 615   3                      }
 616   2                      if((commState1==COMM_STATE_BROADCAST_MESSAGES_PREPARE_STEP_2)){
 617   3                              if(SBUF==COMM_STATE_BROADCAST_PREPARE_2){
 618   4                                      commState1=COMM_STATE_BROADCAST_MESSAGES_PREPARE_STEP_3;
 619   4                              }
 620   3                              else{
 621   4                                      commState1=COMM_STATE_NOTHING;
 622   4                              }
 623   3                              return;
 624   3                      }
 625   2                      if((commState1==COMM_STATE_BROADCAST_MESSAGES_PREPARE_STEP_3)){
 626   3                              if(SBUF==COMM_STATE_BROADCAST_PREPARE_3){
 627   4                                      commState1=COMM_STATE_BROADCAST_MESSAGES;
 628   4                                      messagesBufIndex=0;
 629   4                                      tempMessageNum=0;
 630   4                              }
 631   3                              else{
 632   4                                      commState1=COMM_STATE_NOTHING;
 633   4                              }
 634   3                              return;
 635   3              
 636   3                      }
 637   2                      if(commState1==COMM_STATE_BROADCAST_MESSAGES){
 638   3                              LED_RXD1=~LED_RXD1;
 639   3                              messagesBuf[messagesBufIndex++]=SBUF;
 640   3                              if(messagesBufIndex==2){
 641   4                                      tempMessageNum=(((messagesBuf[0]<<4)&0x0f)+messagesBuf[1]);
 642   4      
 643   4                              }
 644   3                              if(messagesBufIndex>=(tempMessageNum*SENTENCE_LEN+2)*2){
 645   4                                      LED_RXD1=1;//Ö¸Ê¾µÆÃð
 646   4                                      receiveMessagesFlag=1;
 647   4                              }
 648   3                      
 649   3                      }else if(commState1==COMM_STATE_UPDATE_RACK_STAFF){
 650   3                              if((SBUF&0xf0)!=DATA_PRE_UPDATE_RACK_STAFF){
 651   4                                      commState1=COMM_STATE_NOTHING;
 652   4                                      return;
 653   4                              }
 654   3                              staffBuf[staffBufIndex++]=SBUF;
 655   3                              
 656   3                              if(staffBufIndex>=(FIELD_COUNT*STAFF_INFO_FIELD_LENGTN+1)*2){
 657   4                                      LED_TEST=~LED_TEST;
 658   4                                      TR0=0;
 659   4                                      IE2 = 0x00;
 660   4                                      ES=0;           
 661   4                                      makeUpdateStaff();
 662   4                                      commState1=COMM_STATE_NOTHING;
 663   4                                      LED_TXD2=1;//Ö¸Ê¾µÆÃð
 664   4                                      TR0=1;
 665   4                                      IE2 = 0x01;
 666   4                                      ES=1; 
 667   4                              }
 668   3                      }
 669   2                      else if(commState1==COMM_STATE_OPEN_DOOR){
 670   3                                      TR0=0;
 671   3                                      IE2 = 0x00;
C51 COMPILER V9.01   MAIN                                                                  02/17/2014 16:03:40 PAGE 12  

 672   3                                      ES=0;
 673   3                                      lockAddr=SBUF;          
 674   3                                      switchIfNecessary(lockAddr);
 675   3                                      sendCmdAndAddrInstance(CMD_OPEN_DOOR,lockAddr);
 676   3      
 677   3                                      commState1=COMM_STATE_NOTHING;
 678   3                                      LED_TXD2=1;//Ö¸Ê¾µÆÃð
 679   3                                      TR0=1;
 680   3                                      IE2 = 0x01;
 681   3                                      ES=1; 
 682   3                      }
 683   2      
 684   2                     
 685   2              }
 686   1              else if(TI){                       
 687   2                      TI=0;
 688   2              }
 689   1      
 690   1      }
 691          
 692          
 693          void showAddress(uchar x,uchar y){
 694   1              uchar localAddressArr[3];
 695   1              configValueArr[CONFIG_ADDR]=configValueArr[CONFIG_ADDR]%100;
 696   1              localAddressArr[0]='0'+(configValueArr[CONFIG_ADDR]/10);
 697   1              localAddressArr[1]='0'+(configValueArr[CONFIG_ADDR]%10);
 698   1              localAddressArr[2]='\0';
 699   1              LCD_PutString(x,y,localAddressArr);
 700   1      }
 701          char * itostr(uchar num,char * str, uchar strLen){
 702   1              uchar m;
 703   1              for(m=0;m<strLen;m++){
 704   2                      str[m]='0';
 705   2              }
 706   1              while (num!=0){
 707   2                  str[--m]='0'+(num%10);
 708   2                      num/=10;
 709   2              }
 710   1              str[strLen]='\0';
 711   1              return str;
 712   1      }
 713          char  xdata emptyStat[4]={'\0'};
 714          char  xdata chargingStat[4]={'\0'};
 715          char  xdata fullStat[4]={'\0'};
 716          void displayStatisticsMessage(){
 717   1          if(inSetting==1)
 718   1                      return;
 719   1              
 720   1      
 721   1              LCD_PutString(0,1,"ÏÂ¾®£º");
 722   1              LCD_PutString(0,2,"³äµç£º");
 723   1              LCD_PutString(0,3,"³äÂú£º");
 724   1              LCD_PutString(4,1,itostr(stateStat[1],emptyStat,3));
 725   1              LCD_PutString(4,2,itostr(stateStat[2],chargingStat,3));
 726   1              LCD_PutString(4,3,itostr(stateStat[3],fullStat,3));
 727   1      //  LCD_PutString(0,1,itostr(stateStat[1],emptyStat,3));
 728   1      //      LCD_PutString(0,2,itostr(stateStat[2],chargingStat,3));
 729   1      //      LCD_PutString(0,3,itostr(stateStat[3],fullStat,3)); 
 730   1      //      LCD_PutString(4,1,itostr(stateStat[5],chargingStat,3));
 731   1      //      LCD_PutString(4,2,itostr(stateStat[0],fullStat,3));
 732   1              LCD_PutString(5,4,"µÆ¼Ü");
 733   1              showAddress(7,4);
C51 COMPILER V9.01   MAIN                                                                  02/17/2014 16:03:40 PAGE 13  

 734   1      }
 735          void displayLEDMessage(uchar message[],uchar len){
 736   1              uchar m,indexi=0,indexj=0,count=0,isChinese=0,engliseAl=0,totalPrintCount=0;
 737   1              uchar xdata displayArray[4][10]={'\0'};
 738   1      
 739   1              for(m=0;m<len;m++){
 740   2                      if((isChinese==0)&&(message[m]&0x80)==0x80){
 741   3                              if(engliseAl%2!=0){
 742   4                                      displayArray[indexi][indexj++]=' ';
 743   4                                      count++;
 744   4                                      totalPrintCount++;
 745   4                                      engliseAl=0;
 746   4                                      m--;//ÖØÐÂ¶ÁÈ¡¸Ã×Ö½Ú
 747   4                              }
 748   3                              else
 749   3                              {
 750   4                                      displayArray[indexi][indexj++]=message[m];
 751   4                                      isChinese=1;
 752   4                              }
 753   3                      }
 754   2                      else{
 755   3                              if(isChinese==0){
 756   4                                      engliseAl++;
 757   4                              }
 758   3                              displayArray[indexi][indexj++]=message[m];
 759   3                              count++;
 760   3                              isChinese=0;
 761   3                              totalPrintCount++;
 762   3                      }
 763   2                      if(totalPrintCount==len){
 764   3                              displayArray[indexi][indexj]='\0';
 765   3                      }
 766   2                      if(count==4){
 767   3                              displayArray[indexi][indexj]='\0';
 768   3                              indexi++;
 769   3                              indexj=0;
 770   3                              count=0;
 771   3                      }
 772   2                      if(indexi>=4){ //×î¶àÏÔÊ¾4ÐÐ
 773   3                              break;
 774   3                      }
 775   2                      
 776   2              }
 777   1              for(m=0;m<4;m++){
 778   2                      LCD_PutString(0,m+1,displayArray[m]);
 779   2              }
 780   1              /*              //µ÷ÊÔ
 781   1                              {
 782   1                              
 783   1                                      uchar firstState[4]={'\0'};
 784   1                                      firstState[0]='0'+(unitStateArr[1]/100);
 785   1                                      firstState[1]='0'+((unitStateArr[1]%100)/10);
 786   1                                      firstState[2]='0'+(unitStateArr[1]%10);
 787   1                                      firstState[3]='\0';
 788   1                                      LCD_PutString(0,4,firstState);
 789   1                              }
 790   1              
 791   1              */
 792   1      }
 793          
 794          void displayCurrentLedMessage(bit isFirst){
 795   1                      //¹¦ÄÜÉèÖÃÖÐ
C51 COMPILER V9.01   MAIN                                                                  02/17/2014 16:03:40 PAGE 14  

 796   1              if(inSetting==1){
 797   2                      return;
 798   2              }
 799   1              
 800   1              ClrScreen(); 
 801   1              if(configValueArr[CONFIG_MSG_NUM]>0){
 802   2                      if(isFirst==1){
 803   3                              curSentenceIndex=0;
 804   3                      }else{
 805   3                              curSentenceIndex=(++curSentenceIndex)%configValueArr[CONFIG_MSG_NUM];
 806   3                      }
 807   2                      displayLEDMessage(messageBuf[curSentenceIndex],SENTENCE_LEN);
 808   2              }
 809   1              LCD_PutString(5,4,"µÆ¼Ü");
 810   1              showAddress(7,4);
 811   1      }
 812          void startSettingIfNecessary(){
 813   1          if(startSetting==1){
 814   2                       
 815   2                      startSetting=0;
 816   2      
 817   2                  inSetting=1;
 818   2                                      
 819   2                      ClrScreen();
 820   2                      LCD_PutString(3,1,"ÉèÖÃ");
 821   2                      setInfraredFlag();
 822   2                      setState=SET_STATE_INIT;
 823   2              
 824   2                      
 825   2              }
 826   1              
 827   1      }
 828          
 829          
 830          void EX0_ISR (void) interrupt 0 
 831          {
 832   1      
 833   1       irExProcess();
 834   1      }
 835          //¶¨Ê±Æ÷0 º¯Êý
 836          uchar ms50Count=0;
 837          void Timer0_isr(void) interrupt 1 using 1
 838          {
 839   1              irTime0Process();
 840   1              if(ms50Count++>83)// Ô¼51ms
 841   1              {
 842   2                      ms50Count=0;
 843   2              
 844   2                      if(changeMessageFlag==0){
 845   3                              changeMessageTimer++;
 846   3                              if(changeMessageTimer>=20*configValueArr[CONFIG_MSG_INTEVAL]){
 847   4                                  changeMessageTimer=0;
 848   4                                      changeMessageFlag=1;
 849   4                              }
 850   3                      }
 851   2              
 852   2                      if(commState2==COMM_STATE_REQ_UNIT_INFO){
 853   3                              reqUnitInfoInteval++;
 854   3                              if(reqUnitInfoInteval==configValueArr[CONFIG_TIMEOUT_THRESHOLD]){
 855   4                                  reqStateTimeout++;
 856   4                                      if(reqStateTimeout>4){
 857   5                                         tempUnitStateArr[currentUnitTotalIndex]=UNIT_STATE_OFFLINE;
C51 COMPILER V9.01   MAIN                                                                  02/17/2014 16:03:40 PAGE 15  

 858   5                                         reqNextUnitInfo();
 859   5                                      }
 860   4                                      else{
 861   5                                         reqCurrentUnitInfo();
 862   5                                      }
 863   4                              }
 864   3                      }
 865   2              //      else if(readStateFlag==0)//×¢Òâ£¡£¡£¡£¡£¡£¡£¡£¡£¡£¡£¡£¡£¡£¡£¡£¡£¡£¡£¡£¡£¡£¡£¡£¡£¡£¡£¡£¡£¡£¡£¡£¡£¡£¡£¡£
             -¡£¡1 ¿¼ÂÇÊÇ·ñelse
 866   2                      else if(commState2==COMM_STATE_NOTHING)
 867   2                      {       
 868   3                              reqStateTimer++;
 869   3                              if(reqStateTimer>=2*queryStateInteval){ 
 870   4                                      reqStateTimer=0;
 871   4                                      readStateFlag=1;
 872   4                                      currentUnitIndex=1;
 873   4                              }
 874   3              /*              else{
 875   3                                      changeMessageTimer++;
 876   3                                      if(changeMessageTimer==20*configValueArr[CONFIG_MSG_INTEVAL]){
 877   3                                              if(configValueArr[CONFIG_MSG_NUM]>0){
 878   3                                                      curSentenceIndex=(++curSentenceIndex)%configValueArr[CONFIG_MSG_NUM];
 879   3                                                      changeMessageFlag=1;
 880   3                                                      changeMessageTimer=0;
 881   3                                              }
 882   3                                      }
 883   3                              }  
 884   3              */
 885   3                      }
 886   2               }
 887   1        
 888   1      }
 889          void init() {
 890   1      
 891   1              RW_485_1=0 ;
 892   1              RW_485_2=1 ;
 893   1              //¶¨Ê±Æ÷0 ·½Ê½1 £¬50ms¡£
 894   1      //      SBUF=0x0;
 895   1              TMOD |= 0x01;                        
 896   1              TL0 = 0xD7;             //ÉèÖÃ¶¨Ê±³õÖµ   16Î» 600us Îó²î1%
 897   1              TH0 = 0xFD;             //ÉèÖÃ¶¨Ê±³õÖµ
 898   1              ET0=1;           
 899   1              TR0=1;   
 900   1      
 901   1              //´®¿Ú1 ·½Ê½1 9600                                      
 902   1      //      SM0 = 0;
 903   1      //      SM1 = 1;
 904   1      //      REN = 1;
 905   1              SCON  = 0x50;    
 906   1              TMOD |= 0x20;
 907   1              TH1 = 0xfd;
 908   1              TL1 = 0xfd;
 909   1              TR1 = 1;
 910   1      
 911   1              //´®¿Ú2 9600bps@11.0592MHz
 912   1              AUXR &= 0xf7;           //²¨ÌØÂÊ²»±¶ËÙ
 913   1              S2CON = 0x50;           //8Î»Êý¾Ý,¿É±ä²¨ÌØÂÊ
 914   1              BRT = 0xDC;             //Éè¶¨¶ÀÁ¢²¨ÌØÂÊ·¢ÉúÆ÷ÖØ×°Öµ
 915   1              AUXR |= 0x04;           //¶ÀÁ¢²¨ÌØÂÊ·¢ÉúÆ÷Ê±ÖÓÎªFosc,¼´1T
 916   1              AUXR |= 0x10;           //Æô¶¯¶ÀÁ¢²¨ÌØÂÊ·¢ÉúÆ÷
 917   1              IE2 = 0x01;     //×îµÍÎ»ES2ÖÃ0£¬¹Ø±Õ´®¿Ú2ÖÐ¶Ï
 918   1              
C51 COMPILER V9.01   MAIN                                                                  02/17/2014 16:03:40 PAGE 16  

 919   1              //12864³õÊ¼»¯
 920   1              if(dispEnableIO==1){ //ÊÇ·ñÊ¹ÓÃÆÁ£¬¸ßµçÆ½Ê¹ÓÃ£¬µÍµçÆ½²»Ê¹ÓÃ
 921   2                      dispFlag=1;
 922   2              }
 923   1              else{
 924   2                      dispFlag=0;
 925   2              }
 926   1              LCD_Init();
 927   1              
 928   1      
 929   1              IPH=0x10;
 930   1              IP=0x10;//ÉèÖÃ´®¿Ú1ÖÐ¶ÏÓÅÏÈ¼¶Îªó{ÓÅÏÈ¼¶
 931   1              ES = 1;
 932   1      
 933   1              //Íâ²¿ÖÐ¶Ï0 ³õÊ¼»¯ Ê¹ºìÍâ¼ì²âÉúÐ§
 934   1              IT0 = 1;   
 935   1              EX0 = 1;
 936   1              EA = 1;
 937   1              
 938   1              isSelected=0;
 939   1          
 940   1                                            
 941   1      }
 942          void afterInitAndRetrieveSetting(){
 943   1               groupNum=configValueArr[CONFIG_UNIT_NUM]/queryUnitsNum; 
 944   1               groupIndex=0;
 945   1      }
 946          /*
 947                  configValueArr[CONFIG_ADDR]=IapReadByte(IAP_ADDRESS+LOCAL_ADDRESS_ADDR);
 948                  if(configValueArr[CONFIG_ADDR]==0xff){
 949                          configValueArr[CONFIG_ADDR]=0;
 950                  }
 951                  
 952                  configValueArr[CONFIG_UNIT_NUM]=IapReadByte(IAP_ADDRESS+UNITS_NUM_ADDR);
 953                  if(configValueArr[CONFIG_UNIT_NUM]==0xff){
 954                          configValueArr[CONFIG_UNIT_NUM] = 100;
 955                  }
 956          
 957                  configValueArr[CONFIG_MSG_NUM]=IapReadByte(IAP_ADDRESS+MESSAGE_NUM_ADDR);
 958                  if(configValueArr[CONFIG_MSG_NUM]==0xff){
 959                          configValueArr[CONFIG_MSG_NUM]=0;
 960                  }
 961                  configValueArr[CONFIG_MSG_INTEVAL]=IapReadByte(IAP_ADDRESS+MESSAGE_INTEVAL_ADDR);
 962                  if(configValueArr[CONFIG_MSG_INTEVAL]==0xff){
 963                          configValueArr[CONFIG_MSG_INTEVAL]=10;
 964                  }
 965                  configValueArr[CONFIG_TIMEOUT_THRESHOLD]=IapReadByte(IAP_ADDRESS+TIMEOUT_THRESHOLD_ADDR);
 966                  if(configValueArr[CONFIG_TIMEOUT_THRESHOLD]==0xff){
 967                          configValueArr[CONFIG_TIMEOUT_THRESHOLD]=1;
 968                  }
 969          */
 970          void retrieveBaseInfo(){
 971   1              uchar m,n;
 972   1      
 973   1      
 974   1              for (m = 0; m < configValueArr[CONFIG_MSG_NUM]; m++) {
 975   2                      for (n = 0; n < SENTENCE_LEN; n++) {
 976   3                              messageBuf[m][n]=IapReadByte(IAP_BASEINFO_ADDRESS+MESSAGE_LIST_ADDR+m*SENTENCE_LEN+n);
 977   3                      }
 978   2              }
 979   1      } 
 980          void retrieveInfo(){
C51 COMPILER V9.01   MAIN                                                                  02/17/2014 16:03:40 PAGE 17  

 981   1              retreiveConfig();
 982   1              retrieveBaseInfo();
 983   1      }
 984          uchar xdata oldStateStat[6];
 985          bit send2LEDFlag=0;
 986          void refreshUnitsInfo(){
 987   1              uchar m,val;
 988   1              //±£´æ²É¼¯Ö®Ç°µÄÈ¡×ß¡¢³äµç¡¢³äÂú×´Ì¬£¬Èç¹û²É¼¯Ç°ºóÃ»ÓÐ±ä»¯£¬Ôò²»ÓÃ¸üÐÂµãÕóÆÁÏÔÊ¾ÄÚÈÝ
 989   1              for(m=1;m<4;m++){
 990   2                      oldStateStat[m]=stateStat[m];
 991   2              }
 992   1              stateStat[0]=stateStat[1]=stateStat[2]=stateStat[3]=stateStat[4]=stateStat[5]=0;
 993   1              for(m=1;m<=configValueArr[CONFIG_UNIT_NUM];m++){
 994   2                      val=tempUnitStateArr[m];
 995   2                      unitStateArr[m]=val;
 996   2                      stateStat[val]++;
 997   2              }
 998   1              stateStat[0]=m;
 999   1              if((oldStateStat[1]==stateStat[1])&&(oldStateStat[2]==stateStat[2])&&(oldStateStat[3]==stateStat[3])){
1000   2                      send2LEDFlag=0;
1001   2              }
1002   1              else{
1003   2                      send2LEDFlag=1;
1004   2              }
1005   1      }
1006          char testNum=0;
1007          void sendSta2LEDIfNecessary(){
1008   1      
1009   1              if(send2LEDFlag==1){
1010   2                 commState2=COMM_STATE_SEND_STA;
1011   2                      TR0=0;
1012   2      
1013   2                      IE2 = 0x00;
1014   2                      switchIfNecessary(121); //20¸öÒ»×éÇÐ»»µ½µÚ6×é Ë÷Òý´Ó0¿ªÊ¼
1015   2                      sendCmdInstance(CMD_SEND_STA);
1016   2                      sendDataWithoutSplitInstance(configValueArr[CONFIG_ADDR]);
1017   2                      sendDataWithoutSplitInstance(stateStat[1]);
1018   2                      sendDataWithoutSplitInstance(stateStat[2]);
1019   2                      sendDataWithoutSplitInstance(stateStat[3]);
1020   2                      sendCmdInstance(SYM_DATA_END);
1021   2                      IE2 = 0x01;
1022   2      
1023   2                      TR0=1;
1024   2                      commState2=COMM_STATE_NOTHING;
1025   2              }
1026   1      }
1027          
1028          void main() {
1029   1              //configValueArr[CONFIG_DEBUG]=DISPLAY_MESSAGE;
1030   1                
1031   1              init();
1032   1              retrieveInfo();
1033   1              afterInitAndRetrieveSetting();
1034   1              makeInfo();
1035   1              if(configValueArr[CONFIG_DEBUG]==DISPLAY_MESSAGE){
1036   2                      displayCurrentLedMessage(1);
1037   2              }
1038   1              else{
1039   2                      ClrScreen();    
1040   2              }
1041   1              WDT_CONTR = 0x3f;//ÉèÖÃ¿´ÃÅ¹·£¬Òç³öÊ±¼ä9.1022s
1042   1      
C51 COMPILER V9.01   MAIN                                                                  02/17/2014 16:03:40 PAGE 18  

1043   1              while (1) {
1044   2                      
1045   2                      tready = 1;
1046   2                      rready = 1;
1047   2                      tready2 = 1;
1048   2                      rready2 = 1;
1049   2                      if(readStateFlag){
1050   3              //              LED_TEST=0;
1051   3                              readStateFlag=0;
1052   3                              tready2=0 ;
1053   3                              commState2=COMM_STATE_REQ_UNIT_INFO;
1054   3              //              makeInfo();
1055   3                              reqCurrentUnitInfo();                   
1056   3                              tready2=1;
1057   3              
1058   3                      }
1059   2      
1060   2                      if(totalRefreshed==1){
1061   3                              totalRefreshed=0;
1062   3                              refreshUnitsInfo();
1063   3                              sendSta2LEDIfNecessary();
1064   3      
1065   3              
1066   3                      }
1067   2                      if(receiveMessagesFlag==1){
1068   3                              receiveMessagesFlag=0;
1069   3                              commState1=COMM_STATE_NOTHING;
1070   3                              makeMessages();
1071   3                      }
1072   2                      if(configValueArr[CONFIG_DEBUG]==DISPLAY_MESSAGE)
1073   2                      {
1074   3                              if(changeMessageFlag==1){
1075   4                                      changeMessageFlag=0;
1076   4                              //      changeMessageTimer=0;//¿¼ÂÇÔÚdisplayCurrentLedMessage();Ö®ºóµ÷ÓÃ
1077   4                                      displayCurrentLedMessage(0);
1078   4                              }
1079   3                      }
1080   2                      else{
1081   3                               displayStatisticsMessage();
1082   3                      }
1083   2                      startSettingIfNecessary();
1084   2                      processSettingIfNecessary();
1085   2                      WDT_CONTR = 0x3f;//ÉèÖÃ¿´ÃÅ¹·£¬Òç³öÊ±¼ä9.1022s
1086   2      
1087   2                      
1088   2              }
1089   1      
1090   1      }
1091          
1092          
1093          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2946    ----
   CONSTANT SIZE    =    107    ----
   XDATA SIZE       =    920      40
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     26      25
   IDATA SIZE       =   ----    ----
   BIT SIZE         =     14       1
END OF MODULE INFORMATION.

C51 COMPILER V9.01   MAIN                                                                  02/17/2014 16:03:40 PAGE 19  


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
