/*
注意！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！11
蒋总的屏CS1、CS2是高电平有效，且延时时间经实践需选为200us
市场上的屏CS1、CS2是低电平有效，且延时时间经实践需选为100us
*/
#include "lcd12864.h"

#define ENABLE 1
#define DISENABLE 0
extern bit infoChanged;
unsigned char xdata null16x16[]={ 
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
};
unsigned char xdata underline16x16[]={ 
0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

};	
unsigned char xdata full16x16[]={ 
0x00,0x00,0x00,0x00,0xfc,0xfc,0xff,0xff,0xff,0xff,0xfc,0xfc,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,

};
unsigned char xdata half16x16[]={ 
0x00,0x00,0x00,0x00,0xfc,0x04,0x07,0x07,0x07,0x07,0x04,0xfc,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,
};

/*unsigned char xdata half16x16[]={
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,  
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff, };*/
unsigned char xdata empty16x16[]={ 
0x00,0x00,0x00,0x00,0xfc,0x04,0x07,0x07,0x07,0x07,0x04,0xfc,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0xff,0x80,0x80,0x80,0x80,0x80,0x80,0xff,0x00,0x00,0x00,0x00,
};

unsigned char xdata error16x16[]={ 
0x00,0x00,0x00,0x00,0xfc,0x24,0x47,0x87,0x87,0x47,0x24,0xfc,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0xff,0x84,0x82,0x81,0x81,0x82,0x84,0xff,0x00,0x00,0x00,0x00,
};
unsigned char xdata arrow16x16[]={ 
0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x90,0xA0,0xC0,0x80,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x02,0x01,0x00,
};
void delayus(uint n)
{
	uint i;
	for(i=0;i<n;i++);
}
void	LCD_WrCmd(uchar port,uchar  cmd)	
{  
delayus(DISPLAY_DELAY_TIME);
	EN=0;
   	if(port==1){
		CS1=ENABLE;
		delayus(DISPLAY_DELAY_TIME);
		CS2=DISENABLE;
		delayus(DISPLAY_DELAY_TIME);
	}
	else
	{
   		CS1=DISENABLE;
		delayus(DISPLAY_DELAY_TIME);
   		CS2=ENABLE;
		delayus(DISPLAY_DELAY_TIME);
   }
   DI=0;	
   RW=0;
   EN=1;
   LCD=cmd; 
   EN=0;
}

void  LCD_WrDat(uchar port ,uchar wrdata) 	
{  
delayus(DISPLAY_DELAY_TIME);
	EN=0;
	if(port==1){
		CS1=ENABLE;
		delayus(DISPLAY_DELAY_TIME);
		CS2=DISENABLE;
		delayus(DISPLAY_DELAY_TIME);
	}else{
   		CS1=DISENABLE;
		delayus(DISPLAY_DELAY_TIME);
   		CS2=ENABLE;
		delayus(DISPLAY_DELAY_TIME);
   }
   DI=1;	
   RW=0;
   EN=1;
   LCD=wrdata; 
   EN=0;
}

void  LCD_DispFill(uchar filldata) 
{  uchar  x, y;
   LCD_WrCmd(1,LCD_STARTROW);
   LCD_WrCmd(2,LCD_STARTROW);	
   for(y=0; y<8; y++)  
   {  LCD_WrCmd(1,LCD_ADDRSTRY+y);
      LCD_WrCmd(1,LCD_ADDRSTRX);
      LCD_WrCmd(2,LCD_ADDRSTRY+y);
      LCD_WrCmd(2,LCD_ADDRSTRX);
   
      for(x=0; x<64; x++)
      {  LCD_WrDat(1,filldata);
         LCD_WrDat(2,filldata);

      }	
   }
}

void  LCD_DispIni(void)			
{

   LCD_RST = 0;	
   delayus(1000);
   LCD_RST = 1;  
   delayus(1000);
   LCD_WrCmd(1,LCD_DISPON);	 
   LCD_WrCmd(1,LCD_STARTROW);
   delayus(1000);	
   LCD_WrCmd(2,LCD_DISPON);	
   LCD_WrCmd(2,LCD_STARTROW);		
   LCD_DispFill(0x00);
   LCD_WrCmd(1,LCD_ADDRSTRY+0);
   LCD_WrCmd(1,LCD_ADDRSTRX+0);
   LCD_WrCmd(2,LCD_ADDRSTRY+0);
   LCD_WrCmd(2,LCD_ADDRSTRX+0);
}



uchar *lbatStateGraph=0;
void FullCGRAM()
{ 
     lbatStateGraph=full16x16;
}   
void HalfCGRAM()
{ 
     lbatStateGraph=half16x16;
}
void EmptyCGRAM()
{ 
     lbatStateGraph=empty16x16;
} 
void ErrorCGRAM()
{ 
     lbatStateGraph=error16x16;
}
void NullCGRAM()
{ 
     lbatStateGraph=null16x16;
}
void DisplayCGRAM(unsigned char cx,unsigned char cy)
{
	
	uchar *p,i,s,page;
	uchar port;
	cy--;
	
	p=lbatStateGraph;
	if(cx<4)
	{
		port=1;
		s=cx<<4;
	}
	else
	{
		port=2;
		s=((cx-4)<<4);
			
	}
	
	for(page=0;page<2;page++)
	{
		LCD_WrCmd(port,0xb8+cy*2+page);
		delayus(100);
		LCD_WrCmd(port,0x40+s);
		delayus(100);
		for(i=0;i<16;i++)
		{
			LCD_WrDat(port,*p);
			delayus(10);
			p++;
		}
	}
} 



void ClrScreen()
{ 
   LCD_DispFill(0x00);
}
